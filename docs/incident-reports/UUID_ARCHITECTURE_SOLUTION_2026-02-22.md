# UUID Architecture Solution - Feb 22, 2026

## üéØ Clarified Requirements

From user (Feb 22, 2026):
1. ‚úÖ **UUID auto-generates in DB** - Postgres creates UUID on INSERT
2. ‚úÖ **Frontend creates without UUID** - New entities don't need UUID field
3. ‚úÖ **Backend returns UUID** - API response includes generated UUID
4. ‚úÖ **ID is user-editable** - Users can rename "SRC 1" ‚Üí "SRC A" anytime
5. ‚úÖ **ID changes sync** - WebSocket broadcasts ID changes to all clients

**This is a standard, industry-proven pattern.**

---

## üìê Architectural Design

### Layer 1: Database Schema (Prisma)

```prisma
model sources {
  uuid                   String           @id @default(uuid())  // ‚Üê AUTO-GENERATED PK
  id                     String                                  // ‚Üê USER-EDITABLE DISPLAY
  production_id          String
  type                   String
  name                   String
  format_assignment_mode String?          @default("system-wide")
  h_res                  Int?
  v_res                  Int?
  rate                   Float?
  standard               String?
  note                   String?
  secondary_device       String?
  blanking               String?
  created_at             DateTime         @default(now())
  updated_at             DateTime         @updatedAt
  version                Int              @default(1)
  field_versions         Json?
  synced_at              DateTime?
  last_modified_by       String?
  is_deleted             Boolean          @default(false)
  
  connections            connections[]
  source_outputs         source_outputs[]
  productions            productions      @relation(fields: [production_id], references: [id], onDelete: Cascade)

  @@unique([production_id, id])           // ‚Üê ID unique within production
  @@index([production_id, is_deleted])
  @@index([type])
}
```

**Key Changes:**
- ‚úÖ `uuid` is PRIMARY KEY with @default(uuid()) - **Postgres generates automatically**
- ‚úÖ `id` is regular String field - **users can edit freely**
- ‚úÖ `@@unique([production_id, id])` - **prevents duplicate IDs per production**
- ‚úÖ No manual UUID assignment needed

**Database Behavior:**
```sql
-- When frontend sends:
INSERT INTO sources (id, production_id, name, ...) 
VALUES ('SRC 1', 'prod-123', 'Laptop', ...);

-- Postgres automatically adds:
-- uuid: 'a1b2c3d4-e5f6-7890-abcd-ef1234567890'

-- SELECT returns both:
-- uuid | id     | name
-- a1b2 | SRC 1  | Laptop
```

---

### Layer 2: API Routes (Backend)

#### Pattern 1: CREATE (POST)

```typescript
// POST /api/sources
router.post('/', async (req: Request, res: Response) => {
  try {
    const { productionId, userId, userName, outputs, ...sourceData } = req.body;
    
    // IMPORTANT: sourceData contains 'id' but NOT 'uuid'
    // Example: { id: "SRC 1", name: "Laptop", type: "Laptop", ... }
    
    await validateProductionExists(productionId);
    const snakeCaseData = toSnakeCase(sourceData);
    
    // Create with Prisma - uuid auto-generated by database
    const source = await prisma.sources.create({
      data: {
        ...snakeCaseData,
        production_id: productionId,
        version: 1,
        is_deleted: false
      }
    });
    
    // source now has uuid from database:
    // { uuid: "a1b2...", id: "SRC 1", name: "Laptop", ... }
    
    // Transform to camelCase for frontend
    const camelCaseSource = toCamelCase(source);
    
    // Broadcast to WebSocket - USE UUID for entityId
    io.to(`production:${productionId}`).emit('entity:created', {
      entityType: 'source',
      entityId: source.uuid,        // ‚Üê UUID for reliable matching
      entity: camelCaseSource,      // ‚Üê Includes uuid field
      userId,
      userName
    });
    
    // Return to client - includes uuid
    res.status(201).json(camelCaseSource);
    
  } catch (error: any) {
    console.error('‚ùå Create source error:', error);
    res.status(500).json({ error: 'Failed to create source' });
  }
});
```

**Flow:**
1. Frontend sends: `{ id: "SRC 1", name: "Laptop" }` (no uuid)
2. Prisma inserts row ‚Üí Postgres generates uuid
3. Prisma returns: `{ uuid: "a1b2...", id: "SRC 1", name: "Laptop" }`
4. WebSocket broadcasts with uuid
5. Frontend receives entity with uuid

#### Pattern 2: UPDATE (PUT)

```typescript
// PUT /api/sources/:uuid
router.put('/:uuid', async (req: Request, res: Response) => {
  try {
    const { userId, userName, outputs, ...sourceData } = req.body;
    
    // sourceData can include CHANGED id field
    // Example: { id: "SRC A", name: "Main Laptop" }
    
    const snakeCaseData = toSnakeCase(sourceData);
    
    // Update using UUID to find record - can update id field
    const source = await prisma.sources.update({
      where: { uuid: req.params.uuid },  // ‚Üê Find by uuid (immutable)
      data: {
        ...snakeCaseData,                // ‚Üê Can include new id value
        version: { increment: 1 },
        updated_at: new Date()
      }
    });
    
    const camelCaseSource = toCamelCase(source);
    
    // Broadcast with uuid
    io.to(`production:${source.production_id}`).emit('entity:updated', {
      entityType: 'source',
      entityId: source.uuid,           // ‚Üê Same uuid, possibly new id
      entity: camelCaseSource,
      userId,
      userName
    });
    
    res.json(camelCaseSource);
    
  } catch (error: any) {
    console.error('‚ùå Update source error:', error);
    res.status(500).json({ error: 'Failed to update source' });
  }
});
```

**ID Edit Flow:**
1. User changes id from "SRC 1" to "SRC A" in UI
2. Frontend sends: `PUT /api/sources/a1b2c3d4` with `{ uuid: "a1b2...", id: "SRC A", ... }`
3. Prisma updates: `UPDATE sources SET id='SRC A' WHERE uuid='a1b2...'`
4. WebSocket broadcasts: All clients update UI to show new ID
5. UUID remains same - references stay valid

#### Pattern 3: GET (Fetch)

```typescript
// GET /api/sources/production/:productionId
router.get('/production/:productionId', async (req: Request, res: Response) => {
  try {
    const sources = await prisma.sources.findMany({
      where: {
        production_id: req.params.productionId,
        is_deleted: false
      },
      include: { source_outputs: true },
      orderBy: { created_at: 'asc' }
    });
    
    // Each source has uuid + id:
    // [
    //   { uuid: "a1b2...", id: "SRC 1", name: "Laptop" },
    //   { uuid: "c3d4...", id: "SRC 2", name: "Server" }
    // ]
    
    res.json(toCamelCase(sources));
    
  } catch (error: any) {
    console.error('‚ùå GET sources error:', error);
    res.status(500).json({ error: 'Failed to fetch sources' });
  }
});
```

#### Pattern 4: DELETE

```typescript
// DELETE /api/sources/:uuid
router.delete('/:uuid', async (req: Request, res: Response) => {
  try {
    const { userId, userName } = req.query;
    
    const source = await prisma.sources.update({
      where: { uuid: req.params.uuid as string },  // ‚Üê Find by uuid
      data: {
        is_deleted: true,
        version: { increment: 1 }
      }
    });
    
    io.to(`production:${source.production_id}`).emit('entity:deleted', {
      entityType: 'source',
      entityId: source.uuid,  // ‚Üê Broadcast uuid
      userId,
      userName
    });
    
    res.json({ success: true });
    
  } catch (error: any) {
    console.error('‚ùå Delete source error:', error);
    res.status(500).json({ error: 'Failed to delete source' });
  }
});
```

---

### Layer 3: Frontend Hooks

```typescript
// src/hooks/useSourcesAPI.ts
export const useSourcesAPI = () => {
  const createSource = useCallback(async (
    productionId: string,
    data: Partial<Source>,  // ‚Üê Can include id, but NOT uuid
    userId: string,
    userName: string
  ): Promise<Source> => {
    const response = await api.post('/sources', {
      ...data,           // data.id = "SRC 1" (user-assigned)
      productionId,
      userId,
      userName
    });
    
    // response.data includes uuid from database:
    // { uuid: "a1b2...", id: "SRC 1", name: "Laptop" }
    return response.data;
  }, []);
  
  const updateSource = useCallback(async (
    uuid: string,        // ‚Üê Use uuid to identify record
    data: Partial<Source>,
    userId: string,
    userName: string
  ): Promise<Source> => {
    const response = await api.put(`/sources/${uuid}`, {
      ...data,           // Can include new id value
      userId,
      userName
    });
    return response.data;
  }, []);
  
  const deleteSource = useCallback(async (
    uuid: string,        // ‚Üê Use uuid
    productionId: string,
    userId: string,
    userName: string
  ): Promise<void> => {
    await api.delete(`/sources/${uuid}?userId=${userId}&userName=${userName}`);
  }, []);
  
  return { createSource, updateSource, deleteSource };
};
```

---

### Layer 4: Frontend Pages

```typescript
// src/pages/Sources.tsx
export const SourcesPage: React.FC = () => {
  const [sources, setSources] = useState<Source[]>([]);
  const sourcesAPI = useSourcesAPI();
  
  // WebSocket sync - USE UUID for matching
  useProductionEvents({
    productionId,
    onEntityCreated: useCallback((event) => {
      if (event.entityType === 'source') {
        setSources(prev => {
          // Check for duplicate using UUID (reliable, immutable)
          if (prev.some(s => s.uuid === event.entity.uuid)) {
            console.log('‚ö†Ô∏è Duplicate UUID detected - skipping');
            return prev;
          }
          console.log('‚úÖ Adding source via WebSocket:', event.entity.id, event.entity.uuid);
          return [...prev, event.entity];
        });
      }
    }, []),
    
    onEntityUpdated: useCallback((event) => {
      if (event.entityType === 'source') {
        setSources(prev => prev.map(s => 
          s.uuid === event.entity.uuid ? event.entity : s  // ‚Üê Match by uuid
        ));
        // If ID changed from "SRC 1" to "SRC A", UI updates automatically
      }
    }, []),
    
    onEntityDeleted: useCallback((event) => {
      if (event.entityType === 'source') {
        setSources(prev => prev.filter(s => s.uuid !== event.entityId));  // ‚Üê Use uuid
      }
    }, [])
  });
  
  // Create handler
  const handleCreate = async (data: Partial<Source>) => {
    try {
      // data.id = "SRC 1" (user entered in form)
      // data does NOT have uuid
      
      const created = await sourcesAPI.createSource(productionId, data, userId, userName);
      
      // created has uuid from backend:
      // { uuid: "a1b2...", id: "SRC 1", name: "Laptop" }
      
      // WebSocket will add to state automatically
      // (or optimistic update here, WebSocket deduplicates by uuid)
      
    } catch (error) {
      console.error('Failed to create source:', error);
    }
  };
  
  // Update handler (including ID edit)
  const handleUpdate = async (source: Source, changes: Partial<Source>) => {
    try {
      // changes might include new id: { id: "SRC A", name: "Updated" }
      await sourcesAPI.updateSource(source.uuid, changes, userId, userName);
      // WebSocket will update state automatically
    } catch (error) {
      console.error('Failed to update source:', error);
    }
  };
  
  // Delete handler
  const handleDelete = async (source: Source) => {
    try {
      await sourcesAPI.deleteSource(source.uuid, productionId, userId, userName);
      // WebSocket will remove from state automatically
    } catch (error) {
      console.error('Failed to delete source:', error);
    }
  };
  
  return (
    // UI renders source.id (user-friendly "SRC 1")
    // But uses source.uuid for keys and handlers
  );
};
```

---

## üîÑ Data Flow Examples

### Example 1: Create New Source

**Step 1: User fills form**
```
ID: "SRC 1"
Name: "Main Laptop"
Type: "Laptop"
```

**Step 2: Frontend sends**
```json
POST /api/sources
{
  "id": "SRC 1",
  "name": "Main Laptop",
  "type": "Laptop",
  "productionId": "prod-123"
}
// Note: No uuid field
```

**Step 3: Backend inserts**
```sql
INSERT INTO sources (id, production_id, name, type)
VALUES ('SRC 1', 'prod-123', 'Main Laptop', 'Laptop');
-- Postgres automatically generates uuid: 'a1b2c3d4-...'
```

**Step 4: Backend returns**
```json
{
  "uuid": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "id": "SRC 1",
  "name": "Main Laptop",
  "type": "Laptop",
  "productionId": "prod-123"
}
```

**Step 5: WebSocket broadcasts**
```json
{
  "entityType": "source",
  "entityId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "entity": {
    "uuid": "a1b2c3d4-...",
    "id": "SRC 1",
    "name": "Main Laptop"
  }
}
```

**Step 6: All clients receive**
- Browser A: Adds to local state, matches by uuid
- Browser B: Adds to local state, matches by uuid
- Both show "SRC 1" in UI

---

### Example 2: Edit Source ID

**Step 1: User changes ID**
```
Old ID: "SRC 1"
New ID: "SRC A"
(uuid remains: "a1b2c3d4-...")
```

**Step 2: Frontend sends**
```json
PUT /api/sources/a1b2c3d4-e5f6-7890-abcd-ef1234567890
{
  "uuid": "a1b2c3d4-...",
  "id": "SRC A",         // ‚Üê Changed
  "name": "Main Laptop",  // ‚Üê Same
  "type": "Laptop"
}
```

**Step 3: Backend updates**
```sql
UPDATE sources 
SET id = 'SRC A', version = version + 1
WHERE uuid = 'a1b2c3d4-e5f6-7890-abcd-ef1234567890';
```

**Step 4: WebSocket broadcasts**
```json
{
  "entityType": "source",
  "entityId": "a1b2c3d4-...",  // ‚Üê Same uuid
  "entity": {
    "uuid": "a1b2c3d4-...",
    "id": "SRC A",              // ‚Üê New ID
    "name": "Main Laptop"
  }
}
```

**Step 5: All clients update**
- Browser A: Finds source by uuid, updates id in UI
- Browser B: Finds source by uuid, updates id in UI
- Both now show "SRC A" instead of "SRC 1"

---

## ‚úÖ Why This Works

### Frontend Benefits
‚úÖ **Create**: No uuid needed - just provide id  
‚úÖ **Update**: Can change id freely - uuid stays same  
‚úÖ **Sync**: UUID never conflicts - reliable matching  
‚úÖ **Display**: Show user-friendly id - uuid is invisible  

### Backend Benefits
‚úÖ **Primary Key**: UUID never changes - stable references  
‚úÖ **Foreign Keys**: References use uuid - immune to ID edits  
‚úÖ **Uniqueness**: Postgres guarantees uuid uniqueness  
‚úÖ **Performance**: UUID index for fast lookups  

### Database Benefits
‚úÖ **No collisions**: @default(uuid()) is cryptographically unique  
‚úÖ **No manual assignment**: Postgres handles generation  
‚úÖ **Immutable PK**: Foreign key references never break  
‚úÖ **Editable display**: Users can rename id without issues  

---

## üõ†Ô∏è Migration Strategy

### Reminder: Feb 10 Rollback Lesson
**What failed:**
- Tried to migrate ALL tables at once
- Migration crashed on Railway
- Code expected uuid but database didn't have it

**What we'll do differently:**
- ‚úÖ ONE table at a time
- ‚úÖ Test locally with production data copy
- ‚úÖ Verify each step before proceeding
- ‚úÖ Document every change

### Phase 1: sources Table (Pilot)

**Step 1.1: Add uuid column (nullable)**
```sql
-- Migration: add_uuid_to_sources_step1
ALTER TABLE sources ADD COLUMN uuid UUID DEFAULT gen_random_uuid();
```

**Step 1.2: Populate uuid for existing rows**
```sql
-- Migration: add_uuid_to_sources_step2
UPDATE sources SET uuid = gen_random_uuid() WHERE uuid IS NULL;
```

**Step 1.3: Make uuid NOT NULL and PRIMARY KEY**
```sql
-- Migration: add_uuid_to_sources_step3
ALTER TABLE sources ALTER COLUMN uuid SET NOT NULL;
ALTER TABLE sources DROP CONSTRAINT sources_pkey;
ALTER TABLE sources ADD PRIMARY KEY (uuid);
CREATE UNIQUE INDEX sources_production_id_id_key ON sources(production_id, id);
```

**Step 1.4: Update code to use uuid**
- Routes: Use uuid in endpoints
- Frontend: Use uuid for matching
- WebSocket: Emit uuid in events

**Step 1.5: Test thoroughly**
- Create source in Browser A ‚Üí syncs to Browser B
- Edit source ID ‚Üí syncs ID change
- Delete source ‚Üí syncs deletion
- Refresh ‚Üí data persists

**Step 1.6: Deploy to Railway**
- Push migration
- Monitor for errors
- Verify production works

**Step 1.7: Wait 24 hours**
- Monitor logs
- Check for issues
- Confirm stability

### Phase 2-N: Repeat for Each Table

**Order** (from simplest to most complex):
1. ‚úÖ sources (pilot)
2. sends
3. ccus
4. cameras
5. connections
6. checklist_items
7. ... other entity tables

**Each table follows same 7-step process above.**

---

## üìã Code Changes Required

### 1. Prisma Schema (schema.prisma)

**For sources table:**
```diff
model sources {
-  id                     String           @id
+  uuid                   String           @id @default(uuid())
+  id                     String
  production_id          String
  type                   String
  name                   String
  // ... other fields
  
  connections            connections[]
  source_outputs         source_outputs[]
  productions            productions      @relation(fields: [production_id], references: [id], onDelete: Cascade)

+ @@unique([production_id, id])
  @@index([production_id, is_deleted])
  @@index([type])
}
```

**For source_outputs (FK references):**
```diff
model source_outputs {
  id         String  @id
- source_id  String
+ source_uuid String
  connector  String
  // ... other fields
  
- sources    sources @relation(fields: [source_id], references: [id])
+ sources    sources @relation(fields: [source_uuid], references: [uuid])
  
- @@index([source_id])
+ @@index([source_uuid])
}
```

### 2. API Routes (sources.ts)

**Endpoints change:**
```diff
- router.get('/:id', async (req, res) => {
+ router.get('/:uuid', async (req, res) => {
    const source = await prisma.sources.findFirst({
-     where: { id: req.params.id }
+     where: { uuid: req.params.uuid }
    });
  });

- router.put('/:id', async (req, res) => {
+ router.put('/:uuid', async (req, res) => {
    const source = await prisma.sources.update({
-     where: { id: req.params.id }
+     where: { uuid: req.params.uuid }
    });
  });

- router.delete('/:id', async (req, res) => {
+ router.delete('/:uuid', async (req, res) => {
    await prisma.sources.update({
-     where: { id: req.params.id }
+     where: { uuid: req.params.uuid }
    });
  });
```

**WebSocket broadcasts:**
```diff
  io.to(`production:${productionId}`).emit('entity:created', {
    entityType: 'source',
-   entityId: source.id,
+   entityId: source.uuid,
    entity: camelCaseSource
  });
```

### 3. Frontend Hooks (useSourcesAPI.ts)

```diff
export const useSourcesAPI = () => {
  const updateSource = useCallback(async (
-   id: string,
+   uuid: string,
    data: Partial<Source>,
    userId: string,
    userName: string
  ) => {
-   const response = await api.put(`/sources/${id}`, { ...data, userId, userName });
+   const response = await api.put(`/sources/${uuid}`, { ...data, userId, userName });
    return response.data;
  }, []);
  
  const deleteSource = useCallback(async (
-   id: string,
+   uuid: string,
    productionId: string,
    userId: string,
    userName: string
  ) => {
-   await api.delete(`/sources/${id}?userId=${userId}&userName=${userName}`);
+   await api.delete(`/sources/${uuid}?userId=${userId}&userName=${userName}`);
  }, []);
};
```

### 4. Frontend Pages (Sources.tsx)

```diff
  useProductionEvents({
    productionId,
    onEntityCreated: useCallback((event) => {
      if (event.entityType === 'source') {
        setSources(prev => {
-         if (prev.some(s => s.id === event.entity.id)) {
+         if (prev.some(s => s.uuid === event.entity.uuid)) {
            return prev;
          }
          return [...prev, event.entity];
        });
      }
    }, []),
    
    onEntityUpdated: useCallback((event) => {
      if (event.entityType === 'source') {
        setSources(prev => prev.map(s => 
-         s.id === event.entity.id ? event.entity : s
+         s.uuid === event.entity.uuid ? event.entity : s
        ));
      }
    }, []),
    
    onEntityDeleted: useCallback((event) => {
      if (event.entityType === 'source') {
-       setSources(prev => prev.filter(s => s.id !== event.entityId));
+       setSources(prev => prev.filter(s => s.uuid !== event.entityId));
      }
    }, [])
  });
```

**Update handlers:**
```diff
- const handleUpdate = async (id: string, changes: Partial<Source>) => {
+ const handleUpdate = async (source: Source, changes: Partial<Source>) => {
-   await sourcesAPI.updateSource(id, changes, userId, userName);
+   await sourcesAPI.updateSource(source.uuid, changes, userId, userName);
  };

- const handleDelete = async (id: string) => {
+ const handleDelete = async (source: Source) => {
-   await sourcesAPI.deleteSource(id, productionId, userId, userName);
+   await sourcesAPI.deleteSource(source.uuid, productionId, userId, userName);
  };
```

### 5. TypeScript Types

```diff
export interface Source {
+ uuid: string;           // Auto-generated PRIMARY KEY
  id: string;             // User-editable display field
  productionId: string;
  name: string;
  type: string;
  // ... other fields
}
```

---

## üéØ Testing Checklist

### Sources Table (After Migration)

**Test 1: Create**
- [ ] Open Browser A, create source with id "SRC 1"
- [ ] Source appears in Browser A with uuid visible in dev tools
- [ ] Source syncs to Browser B instantly
- [ ] Refresh both browsers - source persists
- [ ] Console logs show: "Broadcasting entity:created with entityId: <uuid>"

**Test 2: Edit ID**
- [ ] In Browser A, edit source, change id from "SRC 1" to "SRC A"
- [ ] Browser A updates to show "SRC A"
- [ ] Browser B updates to show "SRC A" (WebSocket sync)
- [ ] Both browsers show same uuid in dev tools
- [ ] Refresh - ID change persists

**Test 3: Edit Other Fields**
- [ ] Change name, type, resolution
- [ ] Changes sync across browsers
- [ ] UUID remains unchanged

**Test 4: Delete**
- [ ] Delete source in Browser A
- [ ] Source removed in Browser B
- [ ] Refresh - source stays deleted

**Test 5: Duplicate ID Prevention**
- [ ] Try to create source with id "SRC A" (already exists)
- [ ] Backend returns error (unique constraint violation)
- [ ] Frontend shows clear error message

**Test 6: Foreign Keys**
- [ ] Create connection referencing source
- [ ] Edit source ID
- [ ] Connection still works (uses uuid FK)

---

## üìä Comparison: Before vs After

| Aspect | BEFORE (id as PK) | AFTER (uuid as PK) |
|--------|-------------------|-------------------|
| **Primary Key** | id (user-editable) | uuid (auto-generated) |
| **ID Field** | PRIMARY KEY | Regular field |
| **Can Edit ID?** | ‚ùå No (breaks references) | ‚úÖ Yes (uuid stays same) |
| **Uniqueness** | Manual generation | Postgres guarantees |
| **WebSocket Match** | By id (can change) | By uuid (immutable) |
| **Foreign Keys** | By id (fragile) | By uuid (stable) |
| **Duplicate Risk** | High (race conditions) | None (crypto-unique) |
| **Migration** | Already done | Required |

---

## üí° Efficiency & Standards

**Is this efficient?**
‚úÖ **YES** - This is the standard pattern used by:
- Ruby on Rails (default since v4)
- Django (recommended via UUIDField)
- Laravel (supported via uuid helper)
- Hasura, Supabase, Firebase (default)

**Why UUID generation in DB is better than frontend:**
‚úÖ **Single source of truth** - Database guarantees uniqueness  
‚úÖ **No race conditions** - No client-side conflicts  
‚úÖ **Less network roundtrips** - No "reserve UUID" API call  
‚úÖ **Simpler frontend** - Less state management  
‚úÖ **Database-level integrity** - Constraints enforced  

**Alternative patterns:**
‚ùå **Frontend generates UUID** - Possible but adds complexity  
‚ùå **Two-step create** - Reserve UUID, then create - slower  
‚ùå **Snowflake IDs** - Twitter's pattern - overkill here  

**Conclusion:** Your proposed approach is the industry standard and most efficient.

---

## üöÄ Next Steps - Awaiting Approval

**If approved, I will:**

1. **Create migration for sources table** (3-step process)
2. **Update sources.ts routes** (use uuid endpoints)
3. **Update Sources.tsx** (use uuid for matching)
4. **Update useSourcesAPI hook** (uuid parameters)
5. **Update types** (add uuid field)
6. **Test locally** (all 6 test cases)
7. **Deploy step-by-step** (monitor each phase)

**Working approach:**
- Start with sources table only
- Verify everything works
- Document any issues
- Then extend to other tables one-by-one

**Estimated timeline:**
- Sources migration: 30-45 minutes
- Testing: 15-20 minutes
- Deploy & monitor: 10 minutes
- **Total for sources**: ~1 hour

**Risk level:** üü° Medium
- Lower risk than Feb 10 (one table at a time)
- Well-documented pattern
- Can rollback if issues

---

## üìö References

- [UUID_MIGRATION_RECOVERY.md](UUID_MIGRATION_RECOVERY.md) - Feb 10 rollback lessons
- [ID_ARCHITECTURE_CONFLICT_2026-02-21.md](ID_ARCHITECTURE_CONFLICT_2026-02-21.md) - Investigation
- [PostgreSQL UUID Documentation](https://www.postgresql.org/docs/current/datatype-uuid.html)
- [Prisma @default(uuid())](https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#uuid)

**Status**: üü° AWAITING USER APPROVAL TO PROCEED
