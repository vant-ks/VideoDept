import { useState, useCallback } from 'react';
import { apiClient } from '@/services/apiClient';
import type { Source } from '@/types';

interface CreateSourceInput {
  id?: string;  // Optional - will be generated by backend if not provided
  productionId: string;
  userId?: string;
  userName?: string;
  category: string; // Base category: COMPUTER, SERVER, CAMERA, CCU
  type?: string; // Settings-defined type (e.g., "Laptop - PC GFX")
  name: string;
  hRes: number;
  vRes: number;
  rate: number;
  outputs?: string[];
  note?: string;
}

interface UpdateSourceInput extends Partial<CreateSourceInput> {
  version?: number;
}

interface ConflictError {
  error: string;
  message: string;
  currentVersion: number;
  clientVersion: number;
}

export function useSourcesAPI() {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getUserInfo = useCallback(() => {
    const userName = localStorage.getItem('user_name') || 'Anonymous';
    const userId = localStorage.getItem('user_id') || 'anonymous';
    return { userId, userName };
  }, []);

  const fetchSources = useCallback(async (productionId: string): Promise<Source[]> => {
    setIsLoading(true);
    setError(null);
    try {
      const data = await apiClient.get<any[]>(`/sources/production/${productionId}`);
      // Map API response (sourceOutputs) to frontend format (outputs)
      return data.map(source => ({
        ...source,
        outputs: source.sourceOutputs || []
      }));
    } catch (err: any) {
      const message = err.response?.data?.error || 'Failed to fetch sources';
      setError(message);
      throw new Error(message);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const createSource = useCallback(async (input: CreateSourceInput): Promise<Source> => {
    setIsLoading(true);
    setError(null);
    try {
      const { userId, userName } = getUserInfo();
      console.log('ðŸš€ Creating source with input:', input);
      console.log('ðŸš€ ProductionId:', input.productionId);
      console.log('ðŸš€ getUserInfo returned:', { userId, userName });
      
      // Explicitly structure the request to prevent string iteration
      const requestData = {
        id: input.id,
        productionId: input.productionId,
        category: input.category,
        type: input.type,
        name: input.name,
        hRes: input.hRes,
        vRes: input.vRes,
        rate: input.rate,
        outputs: input.outputs,
        note: input.note,
        userId,
        userName,
      };
      
      console.log('ðŸš€ Request data BEFORE apiClient.post:', JSON.stringify(requestData, null, 2));
      
      const data = await apiClient.post<any>('/sources', requestData);
      
      console.log('ðŸš€ Response from API:', data);
      
      // Map API response (sourceOutputs) to frontend format (outputs)
      const mappedSource: Source = {
        ...data,
        outputs: data.sourceOutputs || []
      };
      
      return mappedSource;
    } catch (err: any) {
      const message = err.response?.data?.error || err.response?.data?.message || 'Failed to create source';
      setError(message);
      // Re-throw the original error to preserve response data for error handling
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [getUserInfo]);

  const updateSource = useCallback(async (
    uuid: string,
    input: UpdateSourceInput
  ): Promise<Source | ConflictError> => {
    setIsLoading(true);
    setError(null);
    try {
      const { userId, userName } = getUserInfo();
      const data = await apiClient.put<any>(`/sources/${uuid}`, {
        ...input,
        userId,
        userName,
      });
      // Map API response (sourceOutputs) to frontend format (outputs)
      return {
        ...data,
        outputs: data.sourceOutputs || []
      };
    } catch (err: any) {
      if (err.response?.status === 409) {
        // Conflict detected
        const conflictData: ConflictError = err.response.data;
        return conflictData;
      }
      const message = err.response?.data?.error || 'Failed to update source';
      setError(message);
      throw new Error(message);
    } finally {
      setIsLoading(false);
    }
  }, [getUserInfo]);

  const deleteSource = useCallback(async (uuid: string): Promise<void> => {
    setIsLoading(true);
    setError(null);
    try {
      const { userId, userName } = getUserInfo();
      await apiClient.delete(`/sources/${uuid}`, {
        data: { userId, userName }
      });
    } catch (err: any) {
      const message = err.response?.data?.error || 'Failed to delete source';
      setError(message);
      throw new Error(message);
    } finally {
      setIsLoading(false);
    }
  }, [getUserInfo]);

  return {
    isLoading,
    error,
    fetchSources,
    createSource,
    updateSource,
    deleteSource,
  };
}
