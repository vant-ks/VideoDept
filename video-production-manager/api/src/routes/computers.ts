import { Router, Request, Response } from 'express';
import { prisma } from '../server';
import { io } from '../server';
import { recordEvent, calculateDiff } from '../services/eventService';
import { EventType, EventOperation } from '@prisma/client';
import { toCamelCase, toSnakeCase } from '../utils/caseConverter';
import { broadcastEntityUpdate, broadcastEntityCreated, broadcastEntityDeleted } from '../utils/sync-helpers';
import { validateProductionExists } from '../utils/validation-helpers';
import crypto from 'crypto';

const router = Router();

// GET all sources for a production
router.get('/production/:productionId', async (req: Request, res: Response) => {
  try {
    const sources = await prisma.computers.findMany({
      where: {
        production_id: req.params.productionId,
        is_deleted: false
      },
      include: {
        source_outputs: {
          orderBy: { output_index: 'asc' }
        }
      },
      orderBy: { created_at: 'asc' }
    });
    
    const camelSources = toCamelCase(sources);
    // Transform sourceOutputs to outputs for frontend compatibility
    const transformed = camelSources.map((s: any) => ({
      ...s,
      outputs: s.sourceOutputs || [],
      sourceOutputs: undefined
    }));
    
    res.json(transformed);
  } catch (error: any) {
    console.error('âŒ GET sources error:', error);
    res.status(500).json({ error: 'Failed to fetch sources', details: error.message });
  }
});

// GET single source
router.get('/:uuid', async (req: Request, res: Response) => {
  try {
    const source = await prisma.computers.findFirst({
      where: { 
        uuid: req.params.uuid,
        is_deleted: false
      },
      include: { 
        source_outputs: {
          orderBy: { output_index: 'asc' }
        }
      }
    });

    if (!source) {
      return res.status(404).json({ error: 'Source not found' });
    }

    const camelSource = toCamelCase(source);
    // Transform sourceOutputs to outputs for frontend compatibility
    const transformed = {
      ...camelSource,
      outputs: camelSource.sourceOutputs || [],
      sourceOutputs: undefined
    };
    
    res.json(transformed);
  } catch (error: any) {
    console.error('âŒ GET single source error:', error);
    res.status(500).json({ error: 'Failed to fetch source', details: error.message });
  }
});

// POST create source
router.post('/', async (req: Request, res: Response) => {
  console.log('ðŸš¨ðŸš¨ðŸš¨ POST /sources ROUTE HANDLER CALLED ðŸš¨ðŸš¨ðŸš¨');
  console.log('   Timestamp:', new Date().toISOString());
  console.log('   req.body.id:', req.body.id);
  try {
    // Debug logging - log FULL req.body first
    console.log('ðŸ” FULL req.body:', JSON.stringify(req.body, null, 2));
    
    const { outputs, productionId, userId, userName, ...sourceData } = req.body;
    console.log('ðŸ” sourceData after destructuring:', sourceData);
    console.log('ðŸ” sourceData.category:', sourceData.category);
    
    // VALIDATION: Verify production exists in database
    try {
      await validateProductionExists(productionId);
    } catch (validationError: any) {
      console.error('âŒ Production validation failed:', validationError.message);
      return res.status(400).json({ 
        error: validationError.message,
        code: 'PRODUCTION_NOT_FOUND',
        productionId 
      });
    }
    
    // Debug logging
    console.log('ðŸ“ POST /sources - Creating source');
    console.log('   Production ID:', productionId);
    console.log('   Request body:', req.body);
    console.log('   sourceData:', sourceData);
    
    const snakeCaseData = toSnakeCase(sourceData);
    console.log('   Snake case data:', snakeCaseData);
    console.log('   category value:', snakeCaseData.category);

    // BYPASS PRISMA - Use raw SQL to avoid Prisma's broken constraint handling
    const now = new Date();
    
    //  Insert source using raw SQL (uuid auto-generated by DB)
    // NOTE: category is auto-set to "COMPUTER" - user shouldn't specify
    console.log('ðŸ’¾ Inserting source with id:', snakeCaseData.id);
    const insertResult = await prisma.$queryRaw`
      INSERT INTO sources (
        id, production_id, category, name, type, rate, 
        h_res, v_res, standard, note, secondary_device, blanking,
        format_assignment_mode, created_at, updated_at, version, is_deleted
      ) VALUES (
        ${snakeCaseData.id},
        ${productionId},
        'COMPUTER',
        ${snakeCaseData.name},
        ${snakeCaseData.type || null},
        ${snakeCaseData.rate || null},
        ${snakeCaseData.h_res || null},
        ${snakeCaseData.v_res || null},
        ${snakeCaseData.standard || null},
        ${snakeCaseData.note || null},
        ${snakeCaseData.secondary_device || null},
        ${snakeCaseData.blanking || null},
        ${snakeCaseData.format_assignment_mode || 'system-wide'},
        ${now},
        ${now},
        1,
        false
      )
      RETURNING uuid
    ` as any[];
    const createdUuid = insertResult[0].uuid;
    console.log('âœ… Source inserted successfully with uuid:', createdUuid);
    
    // Insert outputs if provided
    if (outputs && outputs.length > 0) {
      console.log('ðŸ’¾ Inserting', outputs.length, 'outputs');
      for (let i = 0; i < outputs.length; i++) {
        const output = outputs[i];
        const snakeCaseOutput = toSnakeCase(output);
        // Generate display ID (uuid is auto-generated by database)
        const outputId = `${snakeCaseData.id}-out-${snakeCaseOutput.output_index || (i + 1)}`;
        // Use the uuid we got from the INSERT RETURNING above
        await prisma.$executeRaw`
          INSERT INTO source_outputs (
            id, source_uuid, source_id, connector, output_index, h_res, v_res, rate, standard
          ) VALUES (
            ${outputId},
            ${createdUuid},
            ${snakeCaseData.id},
            ${snakeCaseOutput.connector},
            ${snakeCaseOutput.output_index || (i + 1)},
            ${snakeCaseOutput.h_res || null},
            ${snakeCaseOutput.v_res || null},
            ${snakeCaseOutput.rate || null},
            ${snakeCaseOutput.standard || null}
          )
        `;
      }
      console.log('âœ… Outputs inserted successfully');
    }
    
    // Fetch the created source back
    console.log('ðŸ” Fetching created using uuid for reliability');
    console.log('ðŸ” Fetching created source with uuid:', createdUuid);
    const source = await prisma.$queryRaw`
      SELECT s.*, 
        json_agg(
          json_build_object(
            'id', so.id,
            'connector', so.connector,
            'output_index', so.output_index,
            'h_res', so.h_res,
            'v_res', so.v_res,
            'rate', so.rate,
            'standard', so.standard
          )
        ) FILTER (WHERE so.id IS NOT NULL) as source_outputs
      FROM sources s
      LEFT JOIN source_outputs so ON s.uuid = so.source_uuid
      WHERE s.uuid = ${createdUuid}
      GROUP BY s.uuid
    ` as any[];
    console.log('âœ… Fetched source:', source.length, 'rows');
    console.log('   Source data:', JSON.stringify(source[0], null, 2));

    const createdSource = source[0];

    // Record CREATE event (use uuid as immutable entityId)
    console.log('ðŸ“ Recording event for source:', createdSource.uuid);
    await recordEvent({
      productionId,
      eventType: EventType.SOURCE,
      operation: EventOperation.CREATE,
      entityId: createdSource.uuid,
      entityData: createdSource,
      userId: userId || 'system',
      userName: userName || 'System',
      version: 1
    });
    console.log('âœ… Event recorded');

    // Broadcast creation via WebSocket using sync-helpers
    console.log('ðŸ“¡ Broadcasting source:created event');
    const camelCaseSource = toCamelCase(createdSource);
    // Map sourceOutputs to outputs for frontend compatibility
    const broadcastData = {
      ...camelCaseSource,
      outputs: camelCaseSource.sourceOutputs || []
    };
    delete broadcastData.sourceOutputs;
    
    broadcastEntityCreated({
      io,
      productionId,
      entityType: 'source',
      entityId: createdSource.uuid,
      data: broadcastData
    });

    console.log('âœ… Sending 201 response');
    res.status(201).json(broadcastData);
  } catch (error: any) {
    console.error('âŒ Create source error:', error);
    console.error('   Error code:', error.code);
    console.error('   Error meta:', error.meta);
    console.error('   Full error:', JSON.stringify(error, null, 2));
    
    res.status(500).json({ error: 'Failed to create source', details: error.message });
  }
});

// PUT update source (with event recording and conflict detection)
router.put('/:uuid', async (req: Request, res: Response) => {
  try {
    const { outputs, userId, userName, version: clientVersion, ...updateData } = req.body;
    
    console.log('ðŸ“ PUT /sources/:uuid - Updating source');
    console.log('   UUID:', req.params.uuid);
    console.log('   note:', updateData.note);
    console.log('   outputs:', JSON.stringify(outputs, null, 2));
    
    // Get current source for diff and conflict detection
    const currentSource = await prisma.computers.findFirst({
      where: { 
        uuid: req.params.uuid,
        is_deleted: false
      },
      include: { source_outputs: true }
    });
    
    if (!currentSource) {
      return res.status(404).json({ error: 'Source not found' });
    }
    
    // Check for version conflict
    if (clientVersion !== undefined && currentSource.version !== clientVersion) {
      return res.status(409).json({
        error: 'Conflict',
        message: 'Source was modified by another user',
        currentVersion: currentSource.version,
        serverData: toCamelCase(currentSource)
      });
    }
    
    const snakeCaseData = toSnakeCase(updateData);
    
    // Use raw SQL to bypass Prisma's composite unique constraint bug
    const newVersion = currentSource.version + 1;
    const lastModifiedBy = userId || 'system';
    const updatedAt = new Date();
    
    await prisma.$executeRaw`
      UPDATE sources
      SET
        id = ${snakeCaseData.id},
        name = ${snakeCaseData.name},
        type = ${snakeCaseData.type || null},
        rate = ${snakeCaseData.rate || null},
        note = ${snakeCaseData.note || null},
        format_assignment_mode = ${snakeCaseData.format_assignment_mode || 'system-wide'},
        h_res = ${snakeCaseData.h_res || null},
        v_res = ${snakeCaseData.v_res || null},
        standard = ${snakeCaseData.standard || null},
        secondary_device = ${snakeCaseData.secondary_device || null},
        blanking = ${snakeCaseData.blanking || null},
        version = ${newVersion},
        last_modified_by = ${lastModifiedBy},
        updated_at = ${updatedAt}
      WHERE uuid = ${req.params.uuid}
    `;
    
    // Handle outputs update - delete old outputs and insert new ones
    if (outputs && Array.isArray(outputs)) {
      console.log('   Updating outputs...');
      // Delete existing outputs
      await prisma.$executeRaw`
        DELETE FROM source_outputs WHERE source_uuid = ${req.params.uuid}
      `;
      
      // Insert new outputs
      for (const output of outputs) {
        const snakeCaseOutput = toSnakeCase(output);
        await prisma.$executeRaw`
          INSERT INTO source_outputs (
            id, source_uuid, source_id, connector, output_index,
            h_res, v_res, rate, standard
          ) VALUES (
            ${snakeCaseOutput.id || `${snakeCaseData.id}-out-${snakeCaseOutput.output_index || 1}`},
            ${req.params.uuid},
            ${snakeCaseData.id},
            ${snakeCaseOutput.connector},
            ${snakeCaseOutput.output_index || 1},
            ${snakeCaseOutput.h_res || null},
            ${snakeCaseOutput.v_res || null},
            ${snakeCaseOutput.rate || null},
            ${snakeCaseOutput.standard || null}
          )
        `;
      }
    }
    
    // Fetch the updated source with raw SQL including ALL output fields
    const updatedSourceRaw = await prisma.$queryRaw`
      SELECT s.*, json_agg(
        json_build_object(
          'uuid', so.uuid,
          'id', so.id,
          'source_uuid', so.source_uuid,
          'source_id', so.source_id,
          'connector', so.connector,
          'output_index', so.output_index,
          'h_res', so.h_res,
          'v_res', so.v_res,
          'rate', so.rate,
          'standard', so.standard,
          'created_at', so.created_at,
          'version', so.version
        )
      ) FILTER (WHERE so.id IS NOT NULL) as source_outputs
      FROM sources s
      LEFT JOIN source_outputs so ON so.source_uuid = s.uuid
      WHERE s.uuid = ${req.params.uuid}
      GROUP BY s.uuid, s.id, s.production_id, s.category, s.name, s.type, s.rate, s.note, s.format_assignment_mode, s.h_res, s.v_res, s.standard, s.secondary_device, s.blanking, s.version, s.last_modified_by, s.updated_at, s.created_at, s.synced_at, s.is_deleted
    `;
    
    console.log('   Updated source:', JSON.stringify(updatedSourceRaw, null, 2));
    
    const updatedSource = Array.isArray(updatedSourceRaw) ? updatedSourceRaw[0] : updatedSourceRaw;
    
    // Calculate diff and record event
    const changes = calculateDiff(currentSource, updatedSource);
    await recordEvent({
      productionId: currentSource.production_id,
      eventType: EventType.SOURCE,
      operation: EventOperation.UPDATE,
      entityId: updatedSource.uuid,
      entityData: updatedSource,
      changes,
      userId: userId || 'system',
      userName: userName || 'System',
      version: newVersion
    });

    // Broadcast update via WebSocket using sync-helpers
    const camelCaseUpdated = toCamelCase(updatedSource);
    const broadcastUpdated = {
      ...camelCaseUpdated,
      outputs: camelCaseUpdated.sourceOutputs || []
    };
    delete broadcastUpdated.sourceOutputs;
    
    broadcastEntityUpdate({
      io,
      productionId: currentSource.production_id,
      entityType: 'source',
      entityId: updatedSource.uuid,
      data: broadcastUpdated
    });

    res.json(broadcastUpdated);
  } catch (error: any) {
    console.error('Update source error:', error);
    res.status(500).json({ error: 'Failed to update source', details: error.message });
  }
});

// DELETE source (soft delete with event recording)
router.delete('/:uuid', async (req: Request, res: Response) => {
  try {
    const { userId, userName } = req.body;
    
    const source = await prisma.computers.findFirst({
      where: { 
        uuid: req.params.uuid,
        is_deleted: false
      },
      include: { source_outputs: true }
    });
    
    if (!source) {
      return res.status(404).json({ error: 'Source not found' });
    }
    
    // Use raw SQL to bypass Prisma's composite unique constraint bug
    const newVersion = source.version + 1;
    const lastModifiedBy = userId || 'system';
    
    await prisma.$executeRaw`
      UPDATE sources
      SET
        is_deleted = true,
        version = ${newVersion},
        last_modified_by = ${lastModifiedBy}
      WHERE uuid = ${req.params.uuid}
    `;
    
    // Fetch the deleted source for the event
    const deletedSourceRaw = await prisma.$queryRaw`
      SELECT s.*, json_agg(
        json_build_object(
          'id', so.id,
          'connector', so.connector,
          'output_index', so.output_index
        )
      ) FILTER (WHERE so.id IS NOT NULL) as source_outputs
      FROM sources s
      LEFT JOIN source_outputs so ON so.source_uuid = s.uuid
      WHERE s.uuid = ${req.params.uuid}
      GROUP BY s.uuid, s.id, s.production_id, s.category, s.name, s.type, s.rate, s.note, s.format_assignment_mode, s.h_res, s.v_res, s.standard, s.secondary_device, s.blanking, s.version, s.last_modified_by, s.updated_at, s.created_at, s.synced_at, s.is_deleted
    `;
    
    const deletedSource = Array.isArray(deletedSourceRaw) ? deletedSourceRaw[0] : deletedSourceRaw;
    
    // Record DELETE event
    await recordEvent({
      productionId: source.production_id,
      eventType: EventType.SOURCE,
      operation: EventOperation.DELETE,
      entityId: deletedSource.uuid,
      entityData: deletedSource,
      userId: userId || 'system',
      userName: userName || 'System',
      version: newVersion
    });

    // Broadcast deletion via WebSocket using sync-helpers
    broadcastEntityDeleted({
      io,
      productionId: source.production_id,
      entityType: 'source',
      entityId: deletedSource.uuid
    });

    res.json({ success: true, message: 'Source deleted' });
  } catch (error: any) {
    console.error('Delete source error:', error);
    res.status(500).json({ error: 'Failed to delete source', details: error.message });
  }
});

export default router;
